<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TP4 - WebVR - Exercice 3</title>

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script>delete AFRAME.components["grabbable"];</script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>
    <style>body { margin:0 }</style>
</head>
<body>
<a-scene shadow="type: pcfsoft" renderer="antialias: true" physics="gravity: -9.8; debug: false" background="color: #88ccee">

    <!-- Lights -->
    <a-entity id="sun" light="type: directional; intensity: 5; castShadow: true" position="-2 4 4" rotation="-45 30 0"></a-entity>
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>

    <!-- Ground -->
    <a-plane rotation="-90 0 0" width="30" height="30" color="#7BC8A4" shadow="receive: true" static-body></a-plane>

    <!-- Objets grabbables -->
    <a-box class="grabbable" position="-1 1 -3" rotation="0 45 0" depth="1" height="1" width="1" color="#4CC3D9"
           shadow="cast: true; receive: true"
           grabbable="usePhysics: only" dynamic-body="mass:1; shape:box"></a-box>

    <a-sphere class="grabbable" position="1 2 -2" radius="0.7" color="#EF2D5E"
              shadow="cast: true; receive: true"
              grabbable="usePhysics: only" dynamic-body="mass:0.5; shape:sphere"></a-sphere>

    <a-cylinder class="grabbable" position="3 1.5 -4" radius="0.5" height="1.4" color="#FFC65D"
                shadow="cast: true; receive: true"
                grabbable="usePhysics: only" dynamic-body="mass:0.75; shape:cylinder"></a-cylinder>

    <!-- Pistolet initial sur table -->
    <a-entity id="gun" class="grabbable"
              gltf-model="url(pistol.glb)"
              scale="0.05 0.05 0.05"
              position="-1 2 -3"
              rotation="0 0 180"
              grabbable="startButtons: gripdown; endButtons: gripup; usePhysics: true"
              dynamic-body="mass:0.6; shape:box">
        <!-- Projectile visible tant que non tiré -->
        <a-entity id="loadedProjectile"
                  gltf-model="url(projectile.glb)"
                  scale="0.2 0.2 0.2"
                  position="0 0.5 0"
                  flat-shading></a-entity>
    </a-entity>

    <!-- Camera rig + mains -->
    <a-entity id="rig" position="0 1 0" joystick-movement="speed:2" snap-turn="angle:30; cooldown:300">
        <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>

        <a-entity id="leftHand"
                  hand-controls="hand: left; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03"></a-entity>

        <a-entity id="rightHand"
                  hand-controls="hand: right; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03"></a-entity>
    </a-entity>

    <a-sky color="#c4f6ff"></a-sky>

    <script>
        // Flat shading low-poly
        AFRAME.registerComponent('flat-shading', {
            init: function () {
                this.el.addEventListener('model-loaded', () => {
                    this.el.object3D.traverse(node => {
                        if (node.isMesh && node.material) {
                            if (Array.isArray(node.material)) node.material.forEach(m => { m.flatShading = true; m.needsUpdate = true; });
                            else { node.material.flatShading = true; node.material.needsUpdate = true; }
                        }
                    });
                });
            }
        });
        document.addEventListener('DOMContentLoaded', ()=> {
            document.querySelectorAll('[gltf-model]').forEach(el => el.setAttribute('flat-shading',''));
        });

        // Déplacement rig
        AFRAME.registerComponent('joystick-movement', {
            schema: { speed: { type: 'number', default: 2 } },
            init: function () {
                const rig = this.el;
                const head = rig.querySelector('#camera');
                const rightHand = rig.querySelector('#rightHand');
                const DEADZONE = 0.1;
                const speed = this.data.speed;
                rightHand.addEventListener('thumbstickmoved', evt => {
                    const dx = evt.detail.x, dy = evt.detail.y;
                    if (Math.abs(dx)<DEADZONE && Math.abs(dy)<DEADZONE) return;
                    const forward = new THREE.Vector3(); head.object3D.getWorldDirection(forward); forward.y=0; forward.normalize();
                    const right = new THREE.Vector3(); right.crossVectors(forward,new THREE.Vector3(0,1,0)).negate();
                    rig.object3D.position.addScaledVector(forward, dy*0.05*speed);
                    rig.object3D.position.addScaledVector(right, dx*0.05*speed);
                });
            }
        });

        // Snap-turn joystick gauche
        AFRAME.registerComponent('snap-turn', {
            schema: { angle: { type:'number', default:30 }, cooldown: { type:'number', default:300 } },
            init: function () {
                const rig = this.el;
                const leftHand = rig.querySelector('#leftHand');
                let lastTurn = 0;
                const angleRad = THREE.MathUtils.degToRad(this.data.angle);
                leftHand.addEventListener('thumbstickmoved', evt => {
                    const now = Date.now(), x=evt.detail.x;
                    if (Math.abs(x)<0.8 || now-lastTurn<this.data.cooldown) return;
                    rig.object3D.rotation.y += (x>0.8?-angleRad:angleRad);
                    lastTurn = now;
                });
            }
        });

        // Tir projectile
        AFRAME.registerComponent('shoot', {
            schema: { cooldown: {type:'int', default:1500}, speed: {type:'number', default:15} },
            init: function() {
                const gun = this.el;
                const rightHand = document.querySelector('#rightHand');
                let canShoot = true;

                function getForwardVector(el) {
                    const vec = new THREE.Vector3(0,0,-1);
                    vec.applyQuaternion(el.object3D.getWorldQuaternion(new THREE.Quaternion()));
                    return vec.normalize();
                }

                rightHand.addEventListener('triggerdown', () => {
                    if (!canShoot) return;
                    if (gun.parentEl !== rightHand) return;
                    const loaded = gun.querySelector('#loadedProjectile');
                    if (!loaded) return;

                    canShoot = false;
                    const spawnPos = new THREE.Vector3();
                    loaded.object3D.getWorldPosition(spawnPos);

                    const p = document.createElement('a-entity');
                    p.setAttribute('gltf-model','url(projectile.glb)');
                    p.setAttribute('scale','0.2 0.2 0.2');
                    p.setAttribute('position',`${spawnPos.x} ${spawnPos.y} ${spawnPos.z}`);
                    p.setAttribute('flat-shading','');
                    gun.sceneEl.appendChild(p);

                    // Physique du projectile
                    p.addEventListener('model-loaded',()=>{
                        p.setAttribute('dynamic-body','mass:0.2; shape:sphere; sphereRadius:0.05');
                    });

                    const velocity = getForwardVector(gun).multiplyScalar(this.data.speed);
                    p.addEventListener('body-loaded',()=>{
                        if(p.body) { p.body.velocity.set(velocity.x, velocity.y, velocity.z); if(p.body.wakeUp) p.body.wakeUp(); }
                    });

                    loaded.setAttribute('visible','false');
                    setTimeout(()=>{ if(p.parentNode) p.parentNode.removeChild(p); },5000);
                    setTimeout(()=>{ loaded.setAttribute('visible','true'); canShoot=true; }, this.data.cooldown);
                });
            }
        });

        document.addEventListener('DOMContentLoaded',()=>{
            const gun = document.querySelector('#gun');
            if(gun && !gun.components.shoot) gun.setAttribute('shoot','cooldown:1500; speed:15');
        });

    </script>
</a-scene>
</body>
</html>
