<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TP4 - WebVR - Pistolet amélioré (grab + cooldown + projectile attaché)</title>

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>
    <style>body { margin:0 }</style>
</head>
<body>
<a-scene shadow="type: pcfsoft" renderer="antialias: true" physics="gravity: -9.8; debug: false" background="color: #88ccee">

    <a-assets>
        <!-- Remplace les chemins si nécessaire -->
        <a-asset-item id="pistolModel" src="pistol.glb"></a-asset-item>
        <a-asset-item id="projModel" src="projectile.glb"></a-asset-item>
    </a-assets>

    <!-- Lights -->
    <a-entity id="sun" light="type: directional; intensity: 5; castShadow: true" position="-2 4 4" rotation="-45 30 0"></a-entity>
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>

    <!-- Ground -->
    <a-plane rotation="-90 0 0" width="30" height="30" color="#7BC8A4" shadow="receive: true" position="0 0 0" static-body></a-plane>

    <!-- Exemples d'objets grabbables (inchangés) -->
    <a-box class="grabbable" position="-1 1 -3" rotation="0 45 0" depth="1" height="1" width="1" color="#4CC3D9"
           shadow="cast: true; receive: true"
           grabbable="usePhysics: only" dynamic-body="mass:1; shape:box"></a-box>

    <a-sphere class="grabbable" position="1 2 -2" radius="0.7" color="#EF2D5E"
              shadow="cast: true; receive: true"
              grabbable="usePhysics: only" dynamic-body="mass:0.5; shape:sphere"></a-sphere>

    <a-cylinder class="grabbable" position="3 1.5 -4" radius="0.5" height="1.4" color="#FFC65D"
                shadow="cast: true; receive: true"
                grabbable="usePhysics: only" dynamic-body="mass:0.75; shape:cylinder"></a-cylinder>

    <!-- Camera rig + controllers -->
    <a-entity id="rig" position="0 1 0" joystick-movement="speed:2" snap-turn="angle:30; cooldown:300">
        <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>

        <!-- Left hand → Snap-turn -->
        <a-entity id="leftHand"
                  hand-controls="hand: left; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03">
        </a-entity>

        <!-- Right hand → Déplacement + arme -->
        <a-entity id="rightHand"
                  hand-controls="hand: right; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03">
        </a-entity>
    </a-entity>

    <a-sky color="#c4f6ff"></a-sky>

    <!-- Stand / support pour le pistolet (pose initiale) -->
    <a-box id="pistolStand" position="-0.6 0.25 -1.8" width="0.5" height="0.5" depth="0.5" color="#6A6A6A" static-body></a-box>

    <!-- Pistolet posé sur le cube, saisissable. Important: garde 'grabbable' pour que super-hands puisse le prendre. -->
    <a-entity id="pistol"
              class="grabbable"
              gltf-model="#pistolModel"
              position="-0.6 0.65 -1.8"
              rotation="0 90 0"
              scale="0.8 0.8 0.8"
              shadow="cast: true; receive: true"
              grabbable="usePhysics: false"
              pistol-grab
              pistol-shooter="projModel: #projModel; speed: 18; mass: 0.12; lifetime: 6000; cooldown: 400">

        <!-- Muzzle: point de sortie - ajuste la position selon ton modèle 3D -->
        <a-entity id="muzzle" position="0 0 0.6"></a-entity>

        <!-- Projectile chargé initialement dans le canon (sera détaché et physiqué au tir) -->
        <a-entity class="loadedProjectile" gltf-model="#projModel" position="0 0 0.45" scale="0.35 0.35 0.35"></a-entity>
    </a-entity>

    <!-- Déplacement joystick droit + snap-turn composants (inchangés) -->
    <script>
        // Déplacement rig avec joystick droit
        AFRAME.registerComponent('joystick-movement', {
            schema: { speed: { type: 'number', default: 2 } },
            init: function () {
                const rig = this.el;
                const head = rig.querySelector('#camera');
                const rightHand = rig.querySelector('#rightHand');
                const DEADZONE = 0.1;
                const speed = this.data.speed;

                rightHand.addEventListener('thumbstickmoved', evt => {
                    const dx = evt.detail.x, dy = evt.detail.y;
                    if(Math.abs(dx)<DEADZONE && Math.abs(dy)<DEADZONE) return;

                    const forward = new THREE.Vector3();
                    head.object3D.getWorldDirection(forward);
                    forward.y=0; forward.normalize();

                    const right = new THREE.Vector3();
                    right.crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

                    const rigPos = rig.object3D.position;
                    rigPos.addScaledVector(forward, dy*0.05*speed);
                    rigPos.addScaledVector(right, dx*0.05*speed);
                });
            }
        });

        // Snap-turn joystick gauche
        AFRAME.registerComponent('snap-turn', {
            schema: { angle:{type:'number', default:30}, cooldown:{type:'number', default:300} },
            init: function () {
                const rig = this.el;
                const leftHand = rig.querySelector('#leftHand');
                let lastTurn = 0;
                const angleRad = THREE.MathUtils.degToRad(this.data.angle);

                leftHand.addEventListener('thumbstickmoved', evt => {
                    const now = Date.now(), x=evt.detail.x;
                    if(Math.abs(x)<0.8 || now-lastTurn<this.data.cooldown) return;
                    if(x>0.8) rig.object3D.rotation.y -= angleRad;
                    else rig.object3D.rotation.y += angleRad;
                    lastTurn = now;
                });
            }
        });
    </script>

    <!-- COMPONENT: pistol-grab -->
    <script>
        AFRAME.registerComponent('pistol-grab', {
            schema: {
                // offsets optionnels si tu veux que le pistolet soit "tenu" avec un offset visuel
                attachPosition: { type: 'vec3', default: { x: 0, y: 0, z: 0 } },
                attachRotation: { type: 'vec3', default: { x: 0, y: 0, z: 0 } }
            },
            init: function () {
                this._origParent = null;
                this._handEl = null;
                this._onGrabStart = this._onGrabStart.bind(this);
                this._onGrabEnd = this._onGrabEnd.bind(this);
                this.el.addEventListener('grab-start', this._onGrabStart);
                this.el.addEventListener('grab-end', this._onGrabEnd);
            },
            _onGrabStart: function (evt) {
                // evt.detail.hand / handEl selon les versions
                const hand = (evt.detail && (evt.detail.hand || evt.detail.handEl || evt.detail.handEntity)) || null;
                if (!hand) return;
                this._handEl = hand;

                // Sauvegarde du parent précédent
                this._origParent = this.el.parentNode || this.el.sceneEl;

                // calculer transform monde actuelle
                const worldPos = new THREE.Vector3();
                const worldQuat = new THREE.Quaternion();
                this.el.object3D.getWorldPosition(worldPos);
                this.el.object3D.getWorldQuaternion(worldQuat);

                // attacher DOM à la main
                hand.appendChild(this.el);

                // calculer position locale (main) correspondante
                const localPos = worldPos.clone();
                hand.object3D.worldToLocal(localPos);

                // calculer quaternion local
                const handQuat = new THREE.Quaternion();
                hand.object3D.getWorldQuaternion(handQuat);
                const handQuatInv = handQuat.clone().invert();
                const localQuat = handQuatInv.multiply(worldQuat);

                // appliquer pos/quat locale
                this.el.object3D.position.copy(localPos);
                this.el.object3D.quaternion.copy(localQuat);

                // appliquer offset si demandé (petit ajustement pour la prise)
                if (this.data.attachPosition) {
                    this.el.object3D.position.add(new THREE.Vector3(this.data.attachPosition.x, this.data.attachPosition.y, this.data.attachPosition.z));
                }
                if (this.data.attachRotation) {
                    const offsetEuler = new THREE.Euler(
                        THREE.MathUtils.degToRad(this.data.attachRotation.x),
                        THREE.MathUtils.degToRad(this.data.attachRotation.y),
                        THREE.MathUtils.degToRad(this.data.attachRotation.z),
                        'YXZ'
                    );
                    const offsetQuat = new THREE.Quaternion().setFromEuler(offsetEuler);
                    this.el.object3D.quaternion.multiply(offsetQuat);
                }
            },
            _onGrabEnd: function (evt) {
                // restore world transform but reparent to original parent
                const worldPos = new THREE.Vector3();
                const worldQuat = new THREE.Quaternion();
                this.el.object3D.getWorldPosition(worldPos);
                this.el.object3D.getWorldQuaternion(worldQuat);

                const parent = this._origParent || this.el.sceneEl;
                parent.appendChild(this.el);

                // convertir world -> parent local
                parent.object3D.worldToLocal(worldPos);
                this.el.object3D.position.copy(worldPos);

                const parentQuat = new THREE.Quaternion();
                parent.object3D.getWorldQuaternion(parentQuat);
                const parentQuatInv = parentQuat.clone().invert();
                const localQuat = parentQuatInv.multiply(worldQuat);
                this.el.object3D.quaternion.copy(localQuat);

                this._handEl = null;
                this._origParent = null;
            },
            remove: function () {
                this.el.removeEventListener('grab-start', this._onGrabStart);
                this.el.removeEventListener('grab-end', this._onGrabEnd);
            }
        });
    </script>

    <!-- COMPONENT: pistol-shooter (cooldown + projectile detach & physics) -->
    <script>
        AFRAME.registerComponent('pistol-shooter', {
            schema: {
                projModel: { type: 'selector' },
                speed: { type: 'number', default: 15 },
                mass: { type: 'number', default: 0.1 },
                lifetime: { type: 'number', default: 5000 },
                cooldown: { type: 'number', default: 300 }
            },
            init: function () {
                this.hand = null;
                this.shootBound = this._onTriggerDown.bind(this);
                this._lastShot = 0;

                this.el.addEventListener('grab-start', (evt) => {
                    const hand = (evt.detail && (evt.detail.hand || evt.detail.handEl || evt.detail.handEntity)) || null;
                    this.hand = hand;
                    if (this.hand) {
                        this.hand.addEventListener('triggerdown', this.shootBound);
                    }
                });
                this.el.addEventListener('grab-end', (evt) => {
                    const hand = (evt.detail && (evt.detail.hand || evt.detail.handEl || evt.detail.handEntity)) || this.hand;
                    if (hand) {
                        hand.removeEventListener('triggerdown', this.shootBound);
                    }
                    this.hand = null;
                });
            },

            _onTriggerDown: function () {
                const now = Date.now();
                if (now - this._lastShot < this.data.cooldown) return; // still cooling
                this._lastShot = now;

                // cherches le projectile chargé sur le pistolet
                const loaded = this.el.querySelector('.loadedProjectile');
                if (loaded) {
                    this._fireAttachedProjectile(loaded);
                } else {
                    // pas de projectile chargé -> spawn nouveau projectile pour le tir
                    this._spawnAndFire();
                }

                // rechargement immédiat : on attache un nouveau projectile visuel au pistolet
                this._createLoadedProjectile();
            },

            _getMuzzleWorld: function () {
                const muzzle = this.el.querySelector('#muzzle') || this.el;
                const pos = new THREE.Vector3();
                const quat = new THREE.Quaternion();
                muzzle.object3D.getWorldPosition(pos);
                muzzle.object3D.getWorldQuaternion(quat);
                return { pos, quat };
            },

            _fireAttachedProjectile: function (projEl) {
                // calcule transform monde avant détachement
                const worldPos = new THREE.Vector3();
                const worldQuat = new THREE.Quaternion();
                projEl.object3D.getWorldPosition(worldPos);
                projEl.object3D.getWorldQuaternion(worldQuat);

                // détach du pistolet et attache à la scène
                const scene = this.el.sceneEl;
                scene.appendChild(projEl);

                // appliquer transform monde (dans la scène, coords = monde)
                projEl.object3D.position.copy(worldPos);
                projEl.object3D.quaternion.copy(worldQuat);

                // activer la physique
                projEl.setAttribute('dynamic-body', `mass: ${this.data.mass}; shape: sphere`);
                projEl.classList.remove('loadedProjectile');

                // direction du tir (depuis le muzzle)
                const { pos: muzzlePos, quat: muzzleQuat } = this._getMuzzleWorld();
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(muzzleQuat).normalize();

                // appliquer vélocité quand body est prêt
                const applyVelocity = () => {
                    if (!projEl.body) {
                        setTimeout(applyVelocity, 10);
                        return;
                    }
                    // set velocity
                    projEl.body.velocity.set(forward.x * this.data.speed, forward.y * this.data.speed, forward.z * this.data.speed);
                    // give a bit of spin
                    projEl.body.angularVelocity.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                };
                projEl.addEventListener('body-loaded', applyVelocity);
                setTimeout(applyVelocity, 0);

                // cleanup après lifetime
                setTimeout(() => {
                    if (projEl.parentNode) projEl.parentNode.removeChild(projEl);
                }, this.data.lifetime);
            },

            _spawnAndFire: function () {
                // fallback: si aucun projectile chargé, on crÃ©e un nouveau projectile et on le tire
                const scene = this.el.sceneEl;
                const proj = document.createElement('a-entity');
                if (this.data.projModel) proj.setAttribute('gltf-model', '#' + this.data.projModel.id);
                else proj.setAttribute('geometry', 'primitive: sphere; radius: 0.05');

                const { pos: muzzlePos, quat: muzzleQuat } = this._getMuzzleWorld();
                proj.object3D.position.copy(muzzlePos);
                proj.object3D.quaternion.copy(muzzleQuat);
                proj.setAttribute('scale', '0.35 0.35 0.35');
                scene.appendChild(proj);

                proj.setAttribute('dynamic-body', `mass: ${this.data.mass}; shape: sphere`);

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(muzzleQuat).normalize();
                const applyVelocity = () => {
                    if (!proj.body) { setTimeout(applyVelocity, 10); return; }
                    proj.body.velocity.set(forward.x * this.data.speed, forward.y * this.data.speed, forward.z * this.data.speed);
                };
                proj.addEventListener('body-loaded', applyVelocity);
                setTimeout(applyVelocity, 0);

                setTimeout(() => { if (proj.parentNode) proj.parentNode.removeChild(proj); }, this.data.lifetime);
            },

            _createLoadedProjectile: function () {
                // enlÃ¨ve d'abord d'Ã©ventuelles anciennes munitions visuelles
                const existing = this.el.querySelectorAll('.loadedProjectile');
                existing.forEach(e => { if (e && e.parentNode) e.parentNode.removeChild(e); });

                // crÃ©e un nouveau projectile visuel attachÃ© au pistolet
                const newLoaded = document.createElement('a-entity');
                if (this.data.projModel) newLoaded.setAttribute('gltf-model', '#' + this.data.projModel.id);
                else newLoaded.setAttribute('geometry', 'primitive: sphere; radius: 0.05');
                newLoaded.classList.add('loadedProjectile');
                // position locale devant le canon (ajuste selon ton modèle)
                newLoaded.setAttribute('position', '0 0 0.45');
                newLoaded.setAttribute('scale', '0.35 0.35 0.35');
                this.el.appendChild(newLoaded);
            }
        });
    </script>

</a-scene>
</body>
</html>