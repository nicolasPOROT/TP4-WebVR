<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TP4 - WebVR - Exercice 3 (pistolet + projectiles)</title>

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script>delete AFRAME.components["grabbable"];</script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>
    <style>body { margin:0 }</style>
</head>
<body>
<a-scene shadow="type: pcfsoft" renderer="antialias: true" physics="gravity: -9.8; debug: false" background="color: #88ccee">

    <a-assets>
        <!-- Mets ici les bons chemins vers tes modèles -->
        <a-asset-item id="pistolModel" src="pistol.glb"></a-asset-item>
        <a-asset-item id="projModel" src="projectile.glb"></a-asset-item>
    </a-assets>

    <!-- Lights -->
    <a-entity id="sun" light="type: directional; intensity: 5; castShadow: true" position="-2 4 4" rotation="-45 30 0"></a-entity>
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>

    <!-- Ground -->
    <a-plane rotation="-90 0 0" width="30" height="30" color="#7BC8A4" shadow="receive: true" position="0 0 0" static-body></a-plane>

    <!-- Grabbables (exemples existants) -->
    <a-box class="grabbable" position="-1 1 -3" rotation="0 45 0" depth="1" height="1" width="1" color="#4CC3D9"
           shadow="cast: true; receive: true"
           grabbable="usePhysics: only" dynamic-body="mass:1; shape:box"></a-box>

    <a-sphere class="grabbable" position="1 2 -2" radius="0.7" color="#EF2D5E"
              shadow="cast: true; receive: true"
              grabbable="usePhysics: only" dynamic-body="mass:0.5; shape:sphere"></a-sphere>

    <a-cylinder class="grabbable" position="3 1.5 -4" radius="0.5" height="1.4" color="#FFC65D"
                shadow="cast: true; receive: true"
                grabbable="usePhysics: only" dynamic-body="mass:0.75; shape:cylinder"></a-cylinder>

    <!-- Camera rig + controllers -->
    <a-entity id="rig" position="0 1 0" joystick-movement="speed:2" snap-turn="angle:30; cooldown:300">
        <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>

        <!-- Left hand → Snap-turn -->
        <a-entity id="leftHand"
                  hand-controls="hand: left; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03">
        </a-entity>

        <!-- Right hand → Déplacement + arme -->
        <a-entity id="rightHand"
                  hand-controls="hand: right; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03">
        </a-entity>
    </a-entity>

    <a-sky color="#c4f6ff"></a-sky>

    <!-- Stand / support pour le pistolet (pose initiale) -->
    <a-box id="pistolStand" position="-0.6 0.25 -1.8" width="0.5" height="0.5" depth="0.5" color="#6A6A6A" static-body></a-box>

    <!-- Pistolet posé sur le cube, saisissable -->
    <a-entity id="pistol"
              class="grabbable"
              gltf-model="#pistolModel"
              position="-0.6 0.65 -1.8"
              rotation="0 0 90"
              scale="0.1 0.1 0.1"
              shadow="cast: true; receive: true"
              grabbable="usePhysics: false"
              pistol-shooter="projModel: #projModel; speed: 18; mass: 0.12; lifetime: 6000">
        <!-- point de sortie du projectile (ajuste la position selon ton modèle) -->
        <a-entity id="muzzle" position="0 0 0.6"></a-entity>
    </a-entity>

    <!-- Déplacement joystick droit + snap-turn composants (inchangés) -->
    <script>
        // Déplacement rig avec joystick droit
        AFRAME.registerComponent('joystick-movement', {
            schema: { speed: { type: 'number', default: 2 } },
            init: function () {
                const rig = this.el;
                const head = rig.querySelector('#camera');
                const rightHand = rig.querySelector('#rightHand');
                const DEADZONE = 0.1;
                const speed = this.data.speed;

                rightHand.addEventListener('thumbstickmoved', evt => {
                    const dx = evt.detail.x, dy = evt.detail.y;
                    if(Math.abs(dx)<DEADZONE && Math.abs(dy)<DEADZONE) return;

                    const forward = new THREE.Vector3();
                    head.object3D.getWorldDirection(forward);
                    forward.y=0; forward.normalize();

                    const right = new THREE.Vector3();
                    right.crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

                    const rigPos = rig.object3D.position;
                    rigPos.addScaledVector(forward, dy*0.05*speed);
                    rigPos.addScaledVector(right, dx*0.05*speed);
                });
            }
        });

        // Snap-turn joystick gauche
        AFRAME.registerComponent('snap-turn', {
            schema: { angle:{type:'number', default:30}, cooldown:{type:'number', default:300} },
            init: function () {
                const rig = this.el;
                const leftHand = rig.querySelector('#leftHand');
                let lastTurn = 0;
                const angleRad = THREE.MathUtils.degToRad(this.data.angle);

                leftHand.addEventListener('thumbstickmoved', evt => {
                    const now = Date.now(), x=evt.detail.x;
                    if(Math.abs(x)<0.8 || now-lastTurn<this.data.cooldown) return;
                    if(x>0.8) rig.object3D.rotation.y -= angleRad;
                    else rig.object3D.rotation.y += angleRad;
                    lastTurn = now;
                });
            }
        });
    </script>

    <!-- COMPONENT: pistol-shooter -->
    <script>
        AFRAME.registerComponent('pistol-shooter', {
            schema: {
                projModel: {type: 'selector'}, // référence au modèle du projectile dans assets
                speed: {type: 'number', default: 15}, // vitesse initiale (m/s-ish)
                mass: {type: 'number', default: 0.1}, // masse du projectile
                lifetime: {type: 'number', default: 5000} // durée de vie en ms avant suppression
            },
            init: function () {
                this.hand = null;
                this.shootBound = this.shoot.bind(this);
                const el = this.el;

                // quand le pistolet est saisi → super-hands émet 'grab-start' sur l'entité saisie
                el.addEventListener('grab-start', (evt) => {
                    // evt.detail.hand contient normalement la main (controller) qui a saisi
                    const hand = evt.detail && (evt.detail.hand || evt.detail.handEl || evt.detail.handEl || evt.detail.handEl);
                    // si pas présent, fallback au target du event
                    this.hand = hand || evt.target.parentEl || null;

                    if (this.hand) {
                        // écoutons la gâchette (triggerdown)
                        this.hand.addEventListener('triggerdown', this.shootBound);
                        // Optionnel: support pour les contrôleurs Oculus / webxr legacy
                        this.hand.addEventListener('abuttondown', this.shootBound);
                    }
                });

                el.addEventListener('grab-end', (evt) => {
                    const hand = evt.detail && (evt.detail.hand || evt.detail.handEl);
                    const actualHand = hand || this.hand;
                    if (actualHand) {
                        actualHand.removeEventListener('triggerdown', this.shootBound);
                        actualHand.removeEventListener('abuttondown', this.shootBound);
                    }
                    this.hand = null;
                });
            },

            shoot: function () {
                const scene = this.el.sceneEl;
                const muzzle = this.el.querySelector('#muzzle') || this.el; // fallback
                const data = this.data;

                // calculer position et direction monde du muzzle
                const muzzleWorldPos = new THREE.Vector3();
                const muzzleWorldQuat = new THREE.Quaternion();
                muzzle.object3D.getWorldPosition(muzzleWorldPos);
                muzzle.object3D.getWorldQuaternion(muzzleWorldQuat);

                // direction avant locale Z- (A-Frame forward = -Z)
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(muzzleWorldQuat).normalize();

                // créer l'entité projectile
                const proj = document.createElement('a-entity');
                if (data.projModel) {
                    // si on a passé un selector vers un <a-asset-item> on utilise gltf-model
                    proj.setAttribute('gltf-model', '#' + data.projModel.id);
                } else {
                    // fallback : simple sphere
                    proj.setAttribute('geometry', 'primitive: sphere; radius: 0.05');
                    proj.setAttribute('material', 'color: #FFAA00');
                }

                // positionner légèrement en avant pour éviter collision immédiate avec le pistolet
                const spawnPos = {
                    x: muzzleWorldPos.x + forward.x * 0.08,
                    y: muzzleWorldPos.y + forward.y * 0.08,
                    z: muzzleWorldPos.z + forward.z * 0.08
                };
                proj.setAttribute('position', `${spawnPos.x} ${spawnPos.y} ${spawnPos.z}`);

                // orientation alignée sur la direction
                const euler = new THREE.Euler().setFromQuaternion(muzzleWorldQuat, 'YXZ');
                proj.setAttribute('rotation', `${THREE.MathUtils.radToDeg(euler.x)} ${THREE.MathUtils.radToDeg(euler.y)} ${THREE.MathUtils.radToDeg(euler.z)}`);

                // physique : dynamic-body. On choisit mass et shape par défaut (box/sphere)
                // Utilise shape: sphere quand le modèle a des volumes simples
                proj.setAttribute('dynamic-body', `mass: ${data.mass}; shape: sphere`);
                proj.setAttribute('class', 'projectile');

                // optionnel : petit scale si nécessaire
                proj.setAttribute('scale', '0.6 0.6 0.6');

                // ajouter au scène
                scene.appendChild(proj);

                // Quand le body est prêt (body-loaded), on applique la vélocité initiale / impulsion
                const applyInitial = () => {
                    if (!proj.body) {
                        // safety, si body pas encore disponible on retente légèrement plus tard
                        setTimeout(applyInitial, 10);
                        return;
                    }
                    // mettre la vélocité initiale
                    const v = new CANNON.Vec3(forward.x * this.data.speed, forward.y * this.data.speed, forward.z * this.data.speed);
                    proj.body.velocity.set(v.x, v.y, v.z);
                    // option: petite rotation/twirl
                    proj.body.angularVelocity.set(Math.random()*2-1, Math.random()*2-1, Math.random()*2-1);
                };
                proj.addEventListener('body-loaded', applyInitial);
                // cas body-loaded déjà créé rapidement
                setTimeout(applyInitial, 0);

                // supprimer après un certain temps pour éviter fuite mémoire
                setTimeout(() => {
                    if (proj.parentNode) proj.parentNode.removeChild(proj);
                }, this.data.lifetime);
            }
        });
    </script>
</a-scene>
</body>
</html>
