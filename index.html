<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TP4 - WebVR - Exercice 3</title>

    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script>delete AFRAME.components["grabbable"];</script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>
    <style>body { margin:0 }</style>
</head>
<body>
<a-scene shadow="type: pcfsoft" renderer="antialias: true" physics="gravity: -9.8; debug: false" background="color: #88ccee">

    <!-- Lights -->
    <a-entity id="sun" light="type: directional; intensity: 5; castShadow: true" position="-2 4 4" rotation="-45 30 0"></a-entity>
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>

    <!-- Ground -->
    <a-plane rotation="-90 0 0" width="30" height="30" color="#7BC8A4" shadow="receive: true" position="0 0 0" static-body></a-plane>

    <!-- Grabbables -->
    <a-box class="grabbable" position="-1 1 -3" rotation="0 45 0" depth="1" height="1" width="1" color="#4CC3D9"
           shadow="cast: true; receive: true"
           grabbable="usePhysics: only" dynamic-body="mass:1; shape:box"></a-box>

    <a-sphere class="grabbable" position="1 2 -2" radius="0.7" color="#EF2D5E"
              shadow="cast: true; receive: true"
              grabbable="usePhysics: only" dynamic-body="mass:0.5; shape:sphere"></a-sphere>

    <a-cylinder class="grabbable" position="3 1.5 -4" radius="0.5" height="1.4" color="#FFC65D"
                shadow="cast: true; receive: true"
                grabbable="usePhysics: only" dynamic-body="mass:0.75; shape:cylinder"></a-cylinder>

    <!-- Camera rig + controllers -->
    <a-entity id="rig" position="0 1 0" joystick-movement="speed:2" snap-turn="angle:30; cooldown:300">
        <a-entity id="camera" camera look-controls position="0 1.6 0"></a-entity>

        <!-- Left hand → Snap-turn -->
        <a-entity id="leftHand"
                  hand-controls="hand: left; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03">
        </a-entity>

        <!-- Right hand → Déplacement + arme -->
        <a-entity id="rightHand"
                  hand-controls="hand: right; handModelStyle: highPoly; color:#ffcccc"
                  sphere-collider="objects: .grabbable"
                  super-hands="grabStartButtons: gripdown, squeezestart; grabEndButtons: gripup, squeezeend"
                  static-body="shape: sphere; sphereRadius:0.03">

            <!-- Arme (rectangle pour le moment) -->
            <a-box id="gun" class="grabbable" position="0 -0.05 -0.1" rotation="0 0 0"
                   depth="0.3" height="0.05" width="0.1" color="#333333"
                   grabbable="usePhysics: only; startButtons: gripdown, squeezestart; endButtons: gripup, squeezeend">
            </a-box>

        </a-entity>
    </a-entity>

    <a-sky color="#c4f6ff"></a-sky>

    <!-- Déplacement joystick droit -->
    <script>
        // Déplacement rig avec joystick droit
        AFRAME.registerComponent('joystick-movement', {
            schema: { speed: { type: 'number', default: 2 } },
            init: function () {
                const rig = this.el;
                const head = rig.querySelector('#camera');
                const rightHand = rig.querySelector('#rightHand');
                const DEADZONE = 0.1;
                const speed = this.data.speed;

                rightHand.addEventListener('thumbstickmoved', evt => {
                    const dx = evt.detail.x, dy = evt.detail.y;
                    if(Math.abs(dx)<DEADZONE && Math.abs(dy)<DEADZONE) return;

                    const forward = new THREE.Vector3();
                    head.object3D.getWorldDirection(forward);
                    forward.y=0; forward.normalize();

                    const right = new THREE.Vector3();
                    right.crossVectors(forward, new THREE.Vector3(0,1,0)).negate();

                    const rigPos = rig.object3D.position;
                    rigPos.addScaledVector(forward, dy*0.05*speed);
                    rigPos.addScaledVector(right, dx*0.05*speed);
                });
            }
        });

        // Snap-turn joystick gauche
        AFRAME.registerComponent('snap-turn', {
            schema: { angle:{type:'number', default:30}, cooldown:{type:'number', default:300} },
            init: function () {
                const rig = this.el;
                const leftHand = rig.querySelector('#leftHand');
                let lastTurn = 0;
                const angleRad = THREE.MathUtils.degToRad(this.data.angle);

                leftHand.addEventListener('thumbstickmoved', evt => {
                    const now = Date.now(), x=evt.detail.x;
                    if(Math.abs(x)<0.8 || now-lastTurn<this.data.cooldown) return;
                    if(x>0.8) rig.object3D.rotation.y -= angleRad;
                    else rig.object3D.rotation.y += angleRad;
                    lastTurn = now;
                });
            }
        });

        // Tir du projectile depuis l'arme
        AFRAME.registerComponent('shoot', {
            init: function () {
                const gun = document.querySelector('#gun');
                const hand = gun.parentEl; // main qui tient l'arme
                hand.addEventListener('triggerdown', () => {
                    const ball = document.createElement('a-sphere');

                    // Position du projectile : centre de la main ou de l’arme
                    const handPos = new THREE.Vector3();
                    hand.object3D.getWorldPosition(handPos);
                    ball.setAttribute('position', handPos);
                    ball.setAttribute('radius', 0.05);
                    ball.setAttribute('color', '#222222');
                    ball.setAttribute('dynamic-body', 'mass:0.1; shape:sphere');

                    // Direction : axe local -Z transformé en coordonnées mondiales
                    const forward = new THREE.Vector3(0, 0, -1); // direction locale "avant"
                    hand.object3D.getWorldDirection(forward);    // pas fiable si rotation locale complexe

                    // -> Meilleure approche : appliquer la matrice mondiale à l’axe local
                    const matrixWorld = hand.object3D.matrixWorld;
                    forward.set(0, 0, -1);                   // axe local
                    forward.applyMatrix4(matrixWorld);       // transforme en coordonnée mondiale
                    forward.sub(handPos).normalize();        // vecteur direction

                    // Appliquer la vitesse
                    const speed = 10;
                    forward.multiplyScalar(speed);

                    ball.addEventListener('body-loaded', () => {
                        ball.body.applyImpulse(
                            new CANNON.Vec3(forward.x, forward.y, forward.z),
                            new CANNON.Vec3().copy(ball.body.position)
                        );
                    });

                    // Supprime après 3 secondes
                    setTimeout(() => ball.parentNode && ball.parentNode.removeChild(ball), 3000);

                    document.querySelector('a-scene').appendChild(ball);
                });

            }
        });

        // Attache le composant shoot à l'arme
        document.addEventListener('DOMContentLoaded', () => {
            const gun = document.querySelector('#gun');
            gun.setAttribute('shoot', '');
        });
    </script>
</a-scene>
</body>
</html>
