<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <title>TP4 - WebVR complet (Ammo + HandTracking + fallback)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- A-Frame (1.5.0 compatible avec hand-tracking docs) -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <!-- movement-controls (aframe-extras) -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.0/dist/aframe-extras.min.js"></script>

    <!-- Physics system v5 (Ammo.js driver) -->
    <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-physics-system@5.0.0/dist/aframe-physics-system.min.js"></script>

    <!-- super-hands (fallback controllers) -->
    <script src="https://cdn.jsdelivr.net/npm/super-hands@4.0.5/dist/super-hands.min.js"></script>

    <style>body { margin: 0; font-family: system-ui, sans-serif; }</style>
</head>
<body>
<a-scene id="scene"
         physics="driver: ammo; gravity: -9.8"
         shadow="type: pcfsoft"
         background="color: #91d0ff">

    <!-- =========================
         Exo1 : Scène, lumières, ombres
         ========================= -->
    <a-entity light="type: ambient; intensity: 0.45"></a-entity>
    <a-entity light="type: directional; intensity: 1; castShadow: true"
              position="-3 8 5" rotation="-45 35 0"></a-entity>

    <a-sky color="#cfefff"></a-sky>

    <!-- Sol (static body) -->
    <a-plane rotation="-90 0 0" width="50" height="50" color="#7BC8A4"
             static-body shadow="receive: true" position="0 0 0"></a-plane>

    <!-- Quelques props statiques pour ombres -->
    <a-box position="-4 0.5 -2" width="2.5" height="1" depth="0.6"
           color="#6c757d" static-body shadow="cast: true; receive: true"></a-box>

    <!-- =========================
         Exo2 : Objets interactifs (grabbable)
         ========================= -->
    <a-entity id="interactables">
        <a-box class="interactable" id="box1" position="-1 1 -3"
               width="0.9" height="0.9" depth="0.9"
               material="color: #4CC3D9"
               shadow="cast: true; receive: true"
               dynamic-body grabbable></a-box>

        <a-sphere class="interactable" id="ball1" position="1 1.8 -2.5"
                  radius="0.6" material="color: #EF2D5E"
                  shadow="cast: true; receive: true"
                  dynamic-body grabbable></a-sphere>

        <a-cylinder class="interactable" id="cyl1" position="3 1.2 -4"
                    radius="0.4" height="1.2" material="color: #FFC65D"
                    shadow="cast: true; receive: true"
                    dynamic-body grabbable></a-cylinder>
    </a-entity>

    <!-- =========================
         Exo3 : Arme (tenue + tir)
         Exo4 : Cibles + effets
         ========================= -->

    <!-- Ammo-ready flag (sera mis à true quand physics initialisé) -->
    <a-entity id="sys" visible="false"></a-entity>

    <!-- Container pour projectiles & cibles -->
    <a-entity id="projectiles"></a-entity>
    <a-entity id="targets"></a-entity>

    <!-- Son d'impact (préchargé) -->
    <a-assets>
        <audio id="hit-sound" src="https://cdn.jsdelivr.net/gh/arewabeats/sample-audio@main/hit.mp3"></audio>
    </a-assets>

    <!-- =========================
         Player rig: movement + hands (hand-tracking + controller fallback)
         ========================= -->
    <a-entity id="rig" position="0 1.6 5" movement-controls="speed: 1.0; fly: false">
        <a-entity camera look-controls position="0 0 0"></a-entity>

        <!-- Hand tracking: si disponible -->
        <a-entity id="ht-left" hand-tracking-grab-controls="hand: left; hoverColor: #8ab4ff"></a-entity>
        <a-entity id="ht-right" hand-tracking-grab-controls="hand: right; hoverColor: #8ab4ff"></a-entity>

        <!-- Controller fallback (visuals + super-hands + sphere-collider) -->
        <a-entity id="ctrl-left"
                  hand-controls="hand: left; handModelStyle: lowPoly"
                  super-hands
                  sphere-collider="objects: .interactable, .target"
                  position="0 0 0"></a-entity>

        <a-entity id="ctrl-right"
                  hand-controls="hand: right; handModelStyle: highPoly"
                  super-hands
                  sphere-collider="objects: .interactable, .target"
                  position="0 0 0">
            <!-- Weapon attach point (a small gun primitive; you can replace by a glTF) -->
            <a-entity id="gun"
                      position="0 -0.02 -0.15"
                      geometry="primitive: box; width:0.06; height:0.03; depth:0.3"
                      material="color: #222"
                      visible="true"></a-entity>
        </a-entity>
    </a-entity>

    <!-- UI hint -->
    <a-entity position="-1.2 2.2 -1.2"
              text="value: Joystick gauche: déplacement\nJoystick droit: rotation\nGâchette/déclenche: tir\nSaisir: pinch (hand-tracking) ou trigger (controller);\nTest: localhost ou HTTPS; utilisez un casque compatible WebXR."
              scale="0.8 0.8 0.8"></a-entity>

    <!-- =========================
         Script : logique (robuste, défensives checks)
         ========================= -->
    <script>
        (function () {
            const scene = document.querySelector('#scene');
            const sys = document.querySelector('#sys');
            const projectiles = document.querySelector('#projectiles');
            const targets = document.querySelector('#targets');
            const HIT_SOUND_ID = 'hit-sound';

            // ---------- Defensive helper ----------
            function safeClassIndexOf(el, substr) {
                const c = el.getAttribute('class') || '';
                return c.indexOf(substr);
            }

            // ---------- rotation via right joystick ----------
            AFRAME.registerComponent('gamepad-rotate', {
                tick: function () {
                    const gps = navigator.getGamepads ? navigator.getGamepads() : [];
                    let gp = null;
                    for (let i = 0; i < gps.length; i++) {
                        const g = gps[i];
                        if (g && g.connected && Array.isArray(g.axes) && g.axes.length >= 4) { gp = g; break; }
                    }
                    if (!gp) return;
                    const rx = gp.axes[2] || 0; // right stick X (fall-back)
                    const dead = 0.18;
                    const strength = Math.abs(rx) > dead ? rx : 0;
                    if (strength) {
                        const rig = document.querySelector('#rig');
                        const current = rig.getAttribute('rotation') || {x:0,y:0,z:0};
                        const turnSpeed = 2.4;
                        rig.setAttribute('rotation', {x: current.x, y: current.y - strength * turnSpeed, z: current.z});
                    }
                }
            });
            scene.setAttribute('gamepad-rotate','');

            // ---------- Utility: create projectile ----------
            function createProjectile(originEl) {
                // originEl: where it spawns (gun or camera)
                const oPos = originEl.object3D.getWorldPosition(new THREE.Vector3());
                const forward = new THREE.Vector3();
                originEl.object3D.getWorldDirection(forward);

                // create a small sphere projectile
                const proj = document.createElement('a-sphere');
                proj.setAttribute('radius', 0.06);
                proj.setAttribute('position', `${oPos.x} ${oPos.y} ${oPos.z}`);
                proj.setAttribute('material', 'color: #fff100; metalness: 0.2');
                proj.setAttribute('dynamic-body', 'mass:0.2'); // physics
                proj.setAttribute('class', 'projectile');
                projectiles.appendChild(proj);

                // wait for physics body to be ready, then apply impulse
                // dynamic-body will create the Ammo body; use small timeout (Ammo loads asynchronously)
                setTimeout(() => {
                    try {
                        // compute impulse vector (forward * speed)
                        const speed = 18;
                        const impulse = {x: forward.x * speed, y: forward.y * speed + 1.5, z: forward.z * speed};
                        // apply impulse using physics-system event (entity has body)
                        if (proj.body) {
                            proj.body.applyImpulse && proj.body.applyImpulse(
                                new Ammo.btVector3(impulse.x, impulse.y, impulse.z),
                                new Ammo.btVector3(0,0,0)
                            );
                        } else if (proj.components && proj.components['dynamic-body'] && proj.components['dynamic-body'].body) {
                            // sometimes the body is at components.dynamic-body.body
                            const b = proj.components['dynamic-body'].body;
                            b.applyImpulse && b.applyImpulse(
                                new Ammo.btVector3(impulse.x, impulse.y, impulse.z),
                                new Ammo.btVector3(0,0,0)
                            );
                        }
                    } catch (err) {
                        // fallback: give an initial velocity if applyImpulse failed
                        // (physics may not be ready)
                        try {
                            proj.setAttribute('velocity', `${forward.x*5} ${forward.y*5+1} ${forward.z*5}`);
                        } catch(e){}
                    }
                }, 80);

                // remove projectile after a while to avoid mem leak
                setTimeout(() => { if (proj.parentNode) proj.parentNode.removeChild(proj); }, 9000);

                // add collide listener to detect hits (will be used on targets side too)
                proj.addEventListener('collide', (e) => {
                    // e.detail.body: the body we collided with
                    // if collided with a target (class contains 'target'), play effect
                    try {
                        const hitEl = e.detail && e.detail.body && e.detail.body.el;
                        if (hitEl) {
                            const c = (hitEl.getAttribute('class')||'');
                            if (c.indexOf('target') !== -1) {
                                // notify target
                                hitEl.emit('hit-by-projectile', { projectile: proj });
                            }
                        }
                    } catch (err) { /* ignore */ }
                });

                return proj;
            }

            // ---------- Shooting handler for controllers ----------
            function attachShootingToController(ctrlEl) {
                // listen to the standard buttondown events and map to shot when trigger pressed
                // handle many possible event shapes defensively
                const tryFire = function (evt) {
                    // Some controllers emit detail.id or detail.button; we defensively fire on any buttondown.
                    const gun = ctrlEl.querySelector('#gun') || ctrlEl; // gun attach preferred
                    createProjectile(gun);
                };
                // Many controllers send 'triggerdown' events (some send 'buttondown'), listen to a few
                ctrlEl.addEventListener('triggerdown', tryFire);
                ctrlEl.addEventListener('buttondown', tryFire);
                ctrlEl.addEventListener('abuttondown', tryFire);
                ctrlEl.addEventListener('bbuttondown', tryFire);
                // Also support super-hands 'grab-start' on the gun to shoot while held
                ctrlEl.addEventListener('gripdown', tryFire);
            }

            // ---------- Targets system (Exo4) ----------
            function spawnTarget() {
                // create a box target with simple physics
                const t = document.createElement('a-box');
                t.setAttribute('width', 0.8);
                t.setAttribute('height', 0.8);
                t.setAttribute('depth', 0.4);
                // random position in front of player
                const x = (Math.random()*8) - 4;
                const y = 1.0 + Math.random()*2.0;
                const z = -4 - Math.random()*6;
                t.setAttribute('position', `${x} ${y} ${z}`);
                t.setAttribute('material', 'color: #ff6b6b');
                t.setAttribute('class', 'target interactable');
                t.setAttribute('dynamic-body', 'mass: 1');
                t.setAttribute('shadow', 'cast: true; receive: true');

                // On collision with projectile, play sound & particle + remove target
                t.addEventListener('hit-by-projectile', (evt) => {
                    // Visual: create a small expanding sphere and remove shortly
                    const p = document.createElement('a-sphere');
                    p.setAttribute('position', t.getAttribute('position'));
                    p.setAttribute('radius', 0.15);
                    p.setAttribute('material', 'color: #ffdf6b; opacity: 0.95; emissive: #ffdf6b');
                    scene.appendChild(p);
                    // animate scale & fade out
                    p.setAttribute('animation__scale', 'property: scale; to: 3 3 3; dur: 350; easing: easeOutQuad');
                    p.setAttribute('animation__fade', 'property: material.opacity; to: 0; dur: 350; easing: linear');
                    setTimeout(()=> p.parentNode && p.parentNode.removeChild(p), 450);

                    // Play hit sound (defensive check)
                    const sound = document.querySelector('#' + 'hit-sound');
                    if (sound && sound.play) {
                        try { sound.play(); } catch(e) { /* ignore */ }
                    }

                    // Remove target after small timeout to allow visual
                    setTimeout(() => { if (t.parentNode) t.parentNode.removeChild(t); }, 120);
                });

                targets.appendChild(t);
                // also let super-hands pick targets (so they can be grabbed)
                return t;
            }

            // spawn repeating targets
            let spawnInterval = null;
            function startSpawningTargets() {
                // create a few immediately, then start an interval
                for (let i=0;i<3;i++) spawnTarget();
                spawnInterval = setInterval(()=> { spawnTarget(); }, 3500);
            }

            // ---------- Hookup on scene loaded / physics ready ----------
            function onSceneReady() {
                // attach shooting to right controller
                const ctrlRight = document.querySelector('#ctrl-right') || document.querySelector('#ht-right');
                if (ctrlRight) attachShootingToController(ctrlRight);

                // ensure controller fallback also fires
                const ctrlLeft = document.querySelector('#ctrl-left') || document.querySelector('#ht-left');
                if (ctrlLeft) attachShootingToController(ctrlLeft);

                // start spawning targets a little after physics init
                setTimeout(() => startSpawningTargets(), 800);

                // visual feedback: add hover/grab events for interactables to avoid indexOf on class directly
                document.querySelectorAll('.interactable, .target').forEach((el) => {
                    // store original color
                    const mat = el.getAttribute('material') || {};
                    const orig = mat.color || '#ffffff';
                    el.addEventListener('mouseenter', () => el.setAttribute('material', 'color', '#8ab4ff'));
                    el.addEventListener('mouseleave', () => {
                        if (!el.isGrabbed) el.setAttribute('material', 'color', orig);
                    });
                    el.addEventListener('grab-start', () => { el.isGrabbed = true; el.setAttribute('material', 'color', '#ffd166'); });
                    el.addEventListener('grab-end', () => { el.isGrabbed = false; setTimeout(()=> el.setAttribute('material','color',orig),100); });
                });
            }

            // Listen for the physics system ready event; aframe-physics-system fires 'physics-ready' on scene
            // Fallback: if not present, use scene loaded.
            let physicsReady = false;
            scene.addEventListener('physicsReady', () => {
                physicsReady = true;
                onSceneReady();
            });
            // older naming or alternative: some builds use 'physicsloaded' or simply wait for 'loaded'
            scene.addEventListener('physics-loaded', () => {
                physicsReady = true;
                onSceneReady();
            });
            scene.addEventListener('loaded', () => {
                // if physics not flagged after short delay, still attempt to init
                setTimeout(()=> { if (!physicsReady) onSceneReady(); }, 600);
            });

            // Safety: if Ammo not yet loaded but physics system exposes global Ammo, wait for it
            // (we keep this tolerant; the physics lib will try to initialize itself)
            // Done: all guarded via timeouts where necessary above.

        })();
    </script>

</a-scene>
</body>
</html>
